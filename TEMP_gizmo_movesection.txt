      double localDeg = _radToDeg(ang - parentY);
      if (widget.angleSnap) {
        localDeg = (localDeg / 15.0).round() * 15.0;
      }

      final frame = widget.t.round();
      final newTracks = Map<String, TrackTransform>.from(inst.boneTracks);
      final tr = newTracks[bid] ?? const TrackTransform();
      final rot = List<KeyF<double>>.from(tr.rotDeg);
      final i = rot.indexWhere((k) => k.t == frame);
      final kv = KeyF<double>(frame, localDeg);
      if (i >= 0) {
        rot[i] = kv;
      } else if (widget.autoKey) {
        rot.add(kv);
      }
      newTracks[bid] = TrackTransform(pos: tr.pos, rotDeg: rot, scale: tr.scale);
      widget.onChange(inst.copyWith(boneTracks: newTracks));
      return;
    }

    // Pole vector drag
    if (_dragPoleBoneId != null) {
      final bid = _dragPoleBoneId!;
      // Update pole vector local position from pointer
      final parentId = _parentIdOf(bid, model);
      if (parentId == null) return;
      final instWorld = _instanceWorld(widget.sequence.instances, inst, widget.t, widget.sequence.setting.interpolate);
      final byId = {for (final b in model.bones) b.id: b};
      final cache = <String, vm.Matrix4>{};
      final parent = byId[parentId]!;
      final parentWorld = instWorld * SkeletonUtil.worldOf(parent, _poseOf(inst, widget.t, interpolate: widget.sequence.setting.interpolate), byId, cache);

      // Screen -> world
      final world = (e.position - widget.viewportOffset) / widget.viewportScale;
      // World -> parent-local
      final inv = vm.Matrix4.inverted(parentWorld);
      final pv = inv.transform3(vm.Vector3(world.dx, world.dy, 0));
      final newLocal = Vec2(pv.x, pv.y);

      final m = Map<String, Vec2>.from(inst.ikPoles);
      m[bid] = newLocal;
      final updated = inst.copyWith(ikPoles: m);
      widget.onChange(updated);
      return;
    }
  }

  void _onPointerUp(PointerEvent e) {
    if (widget.tool == 'lasso') {
      if (_lassoScale) {
        widget.onEditEnd?.call('Lasso Scale');
      } else if (_lassoRotate) {
        widget.onEditEnd?.call('Lasso Rotate');
      } else if (_lassoMove) {
        widget.onEditEnd?.call('Lasso Move');
      } else if (_lassoDrawing) {
        _finalizeLassoSelection();
        widget.onEditEnd?.call('Lasso Select');
      }
      setState(() {
        _lassoDrawing = false;
        _lassoMove = false;
        _lassoRotate = false;
        _lassoScale = false;
      });
      return;
    }
    final label = _dragBase ? 'Move' : (_dragBaseRotate ? 'Rotate' : (_dragIkBoneId != null ? 'IK Drag' : (_dragRotBoneId != null ? 'Rotate Bone' : (_dragPoleBoneId != null ? 'Pole Vector' : 'Gizmo'))));
    widget.onEditEnd?.call(label);
    setState(() {
      _dragPoleBoneId = null;
      _dragIkBoneId = null;
      _dragBase = false;
      _dragBaseRotate = false;
      _dragRotBoneId = null;
      _dragInstId = null;
    });
  }

