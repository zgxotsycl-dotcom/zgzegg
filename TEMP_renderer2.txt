    // torso: from torso pivot to head pivot
    final torsoBase = _wp('torso');
    final headPivot = _wp('head');
    canvas.drawLine(torsoBase, headPivot, torsoP);
    // head circle (use offset -20 in head local)
    final headM = instWorld * SkeletonUtil.worldOf(byId['head']!, pose, byId, cache);
    final headCenter = _tx(headM, const ui.Offset(0,-20));
    canvas.drawCircle(headCenter, headR, ui.Paint()..style=ui.PaintingStyle.stroke..strokeWidth=4*inst.lineWidthScale..color=(tint??const ui.Color(0xFF000000)));

    void arm(String upper, String lower){
      final p0 = _wp(upper);
      final p1 = _wp(lower);
      final p2 = _end(lower, laLen);
      canvas.drawLine(p0, p1, limb);
      canvas.drawLine(p1, p2, limb);
      if (showHelperJoints){ canvas.drawCircle(p0, 4, joint); canvas.drawCircle(p1, 4, joint); canvas.drawCircle(p2, 3, joint); }
    }
    void leg(String thigh, String shin){
      final p0 = _wp(thigh);
      final p1 = _wp(shin);
      final p2 = _end(shin, shLen);
      canvas.drawLine(p0, p1, limb);
      canvas.drawLine(p1, p2, limb);
      if (showHelperJoints){ canvas.drawCircle(p0, 4, joint); canvas.drawCircle(p1, 4, joint); canvas.drawCircle(p2, 3, joint); }
    }
    arm('l_upper_arm','l_lower_arm');
    arm('r_upper_arm','r_lower_arm');
    leg('l_thigh','l_shin');
    leg('r_thigh','r_shin');
  }

  static vm.Matrix4 _instanceWorld(Instance inst, Map<String, Instance> byId, double t, bool interpolate) {
    vm.Matrix4 acc = vm.Matrix4.identity();
    // Build chain from root to this
    final chain = <Instance>[];
    Instance? cur = inst;
    final visited = <String>{};
    while (cur != null) {
      if (visited.contains(cur.id)) break;
      visited.add(cur.id);
      chain.add(cur);
      if (cur.parentId == null) break;
      cur = byId[cur.parentId!];
    }
    for (final it in chain.reversed) {
      final bt = it.baseTrack;
      final tr = bt == null ? it.base : sampleTransform(bt, t, interpolate: interpolate);
      acc = acc * composeMatrix(tr, it.pivot);
    }
    return acc;
  }

  static void _drawImage(ui.Canvas canvas, vm.Matrix4 mat, Attachment a, AttTrack? tr, double t, Map<String, ui.Image> images, {ui.Color? tint}) {
    String? pth = a.imagePath;
    if (a.spriteFrames != null && a.spriteFrames!.isNotEmpty) {
      int idx;
      if (tr != null && tr.frameIndex.isNotEmpty) {
        final v = sampleScalarD(tr.frameIndex, t);
        idx = v.round().clamp(0, a.spriteFrames!.length - 1);
      } else {
        final ti = t.floor();
        final len = a.spriteFrames!.length;
        // 1-based timeline: frame 1 -> sprite index 0
        idx = ((ti - 1) % len + len) % len;
      }
      pth = a.spriteFrames![idx];
    }
    if (pth == null) return;
    final img = images[pth];
    if (img == null) return;

    final sc = tr == null || tr.scale.isEmpty ? const Vec2(1, 1) : sampleVec2D(tr.scale, t);
    final op = tr == null || tr.opacity.isEmpty ? 1.0 : sampleScalarD(tr.opacity, t).clamp(0.0, 1.0);
    final tintKey = tr == null || tr.tint.isEmpty ? const ui.Color(0xFFFFFFFF) : sampleColorI(tr.tint, t);
    final tintColor = tint ?? tintKey;

    final m = mat.storage;
    final tmat = Float64List.fromList([
      m[0], m[1], 0, m[3],
      m[4], m[5], 0, m[7],
      0, 0, 1, 0,
      m[12], m[13], 0, 1,
    ]);
    canvas.save();
    canvas.transform(tmat);

    final w = a.b.x * sc.x;
    final h = a.b.y * sc.y;
    final cx = a.a.x + a.b.x / 2;
    final cy = a.a.y + a.b.y / 2;
    final dst = ui.Rect.fromLTRB(cx - w / 2, cy - h / 2, cx + w / 2, cy + h / 2);
    final src = ui.Rect.fromLTWH(0, 0, img.width.toDouble(), img.height.toDouble());

    final p = ui.Paint()
      ..filterQuality = ui.FilterQuality.high
      ..color = ui.Color.fromARGB((op * 255).round(), 255, 255, 255)
      ..colorFilter = ui.ColorFilter.mode(tintColor, ui.BlendMode.modulate);
    canvas.drawImageRect(img, src, dst, p);
    canvas.restore();
  }

  static ui.Offset _tx(vm.Matrix4 m, ui.Offset o) {
    final v = m.transform3(vm.Vector3(o.dx, o.dy, 0));
    return ui.Offset(v.x, v.y);
  }

  static Float64List _mat2d(vm.Matrix4 mat) => Float64List.fromList([
        mat.entry(0, 0), mat.entry(0, 1), 0, mat.entry(0, 3),
        mat.entry(1, 0), mat.entry(1, 1), 0, mat.entry(1, 3),
        0, 0, 1, 0,
        0, 0, 0, 1,
      ]);

  static double _onionAlpha(double falloff, int k) {
    final f = falloff.clamp(0.0, 1.0);
    return (1.0 * List<double>.generate(k, (_) => f).fold(1.0, (p, e) => p * e)).clamp(0.05, 1.0);
  }

  static ui.Color _applyTintColor(ui.Color base, ui.Color? tint) {
    if (tint == null) return base;
    // Multiply blend approximation in sRGB
    int mult(int a, int b) => ((a * b) / 255).round().clamp(0, 255);
    return ui.Color.fromARGB(
      base.alpha,
      mult(base.red, tint.red),
      mult(base.green, tint.green),
      mult(base.blue, tint.blue),
    );
  }
}
