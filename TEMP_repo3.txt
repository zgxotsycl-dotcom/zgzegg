        id: j['id'],
        name: j['name'],
        lastOpened: (j['lastOpened'] as int?) ?? 0,
        favorite: (j['favorite'] as bool?) ?? false,
        sequences: (j['sequences'] as List).map((e) => _sequenceFromJson(e)).toList(),
      );

  Map<String, dynamic> _sequenceToJson(Sequence s) => {
        'id': s.id,
        'name': s.name,
        'setting': {
          'fps': s.setting.fps,
          'width': s.setting.width,
          'height': s.setting.height,
          'playbackRate': s.setting.playbackRate,
          'totalFrames': s.setting.totalFrames,
          'interpolate': s.setting.interpolate,
        },
        'onion': {
          'prevFrames': s.onion.prevFrames,
          'nextFrames': s.onion.nextFrames,
          'opacityFalloff': s.onion.opacityFalloff,
          'prevColor': s.onion.prevColor.value,
          'nextColor': s.onion.nextColor.value,
        },
        'instances': s.instances.map(_instanceToJson).toList(),
        'audio': s.audio
            .map((a) => {
                  'path': a.path,
                  'offsetSec': a.offsetSec,
                  'gain': a.gain,
                  'mute': a.mute
                })
            .toList(),
      };

  Sequence _sequenceFromJson(Map<String, dynamic> j) => Sequence(
        id: j['id'],
        name: j['name'],
        setting: SequenceSetting(
          fps: j['setting']['fps'],
          width: j['setting']['width'],
          height: j['setting']['height'],
          playbackRate: (j['setting']['playbackRate'] ?? 1.0) * 1.0,
          totalFrames: (j['setting']['totalFrames'] ?? 300) as int,
          interpolate: (j['setting']['interpolate'] ?? true) as bool,
        ),
        onion: OnionSkinSetting(
          prevFrames: j['onion']['prevFrames'],
          nextFrames: j['onion']['nextFrames'],
          opacityFalloff: (j['onion']['opacityFalloff'] as num).toDouble(),
          prevColor: ui.Color(j['onion']['prevColor']),
          nextColor: ui.Color(j['onion']['nextColor']),
        ),
        instances: (j['instances'] as List).map((e) => _instanceFromJson(e)).toList(),
        audio: (j['audio'] as List? ?? [])
            .map((a) => AudioTrack(
                  path: a['path'],
                  offsetSec: (a['offsetSec'] ?? 0) * 1.0,
                  gain: (a['gain'] ?? 1.0) * 1.0,
                  mute: (a['mute'] ?? false) as bool,
                ))
            .toList(),
      );

  Map<String, dynamic> _instanceToJson(Instance i) => {
        'id': i.id,
        'name': i.name,
        'modelId': i.modelId,
        'base': {
          'pos': i.base.pos.toJson(),
          'rotDeg': i.base.rotDeg,
          'scale': i.base.scale.toJson()
        },
        if (i.baseTrack != null) 'baseTrack': _trackToJson(i.baseTrack!),
        'visible': i.visible,
        'locked': i.locked,
        'pivot': i.pivot.toJson(),
        'parentId': i.parentId,
        'lineWidthScale': i.lineWidthScale,
        'ikPoles': i.ikPoles.map((k,v)=> MapEntry(k, v.toJson())),
        'boneTracks': i.boneTracks.map((k, v) => MapEntry(k, _trackToJson(v))),
        'attachmentTracks': i.attachmentTracks.map((k, v) => MapEntry(k, { 'scale': v.scale.map((e) => {'t': e.t, 'v': e.v.toJson(), 'e': e.easing?.type}).toList(), 'opacity': v.opacity.map((e) => {'t': e.t, 'v': e.v, 'e': e.easing?.type}).toList(), 'tint': v.tint.map((e) => {'t': e.t, 'v': e.v, 'e': e.easing?.type}).toList(), 'frame': v.frameIndex.map((e) => {'t': e.t, 'v': e.v, 'e': e.easing?.type}).toList(), 'offset': v.offset.map((e) => {'t': e.t, 'v': e.v.toJson(), 'e': e.easing?.type}).toList(), })), 'anchorTracks': i.anchorTracks.map((k, list) => MapEntry(k, list.map((e)=> {'t': e.t, 'v': e.v.toJson()}).toList())),
      };

  Instance _instanceFromJson(Map<String, dynamic> j) {
    final at = <String, AttTrack>{};
    final m = j['attachmentTracks'] as Map<String, dynamic>?;
    if (m != null) {
      for (final entry in m.entries) {
        final v = entry.value as Map<String, dynamic>;
        final sc = (v['scale'] as List? ?? []).map((e) => KeyF<Vec2>(e['t'], Vec2.fromJson(e['v']), easing: e['e'] != null ? Easing(e['e']) : null)).toList();
        final op = (v['opacity'] as List? ?? []).map((e) => KeyF<double>(e['t'], (e['v'] as num).toDouble(), easing: e['e'] != null ? Easing(e['e']) : null)).toList();
        final ti = (v['tint'] as List? ?? []).map((e) => KeyF<int>(e['t'], e['v'] as int, easing: e['e'] != null ? Easing(e['e']) : null)).toList();
        final fr = (v['frame'] as List? ?? []).map((e) => KeyF<double>(e['t'], (e['v'] as num).toDouble(), easing: e['e'] != null ? Easing(e['e']) : null)).toList();
        final of = (v['offset'] as List? ?? []).map((e) => KeyF<Vec2>(e['t'], Vec2.fromJson(e['v']), easing: e['e'] != null ? Easing(e['e']) : null)).toList();
        at[entry.key] = AttTrack(scale: sc, opacity: op, tint: ti, frameIndex: fr, offset: of);
      }
    }
    final poles = <String, Vec2>{};
    final mp = j['ikPoles'] as Map<String, dynamic>?;
    if (mp != null) {
      for (final e in mp.entries) {
        final v = e.value as Map<String, dynamic>;
        poles[e.key] = Vec2.fromJson(v);
      }
    }
    return Instance(
      id: j['id'],
      name: j['name'] ?? 'Layer',
      modelId: j['modelId'],
      base: Transform2D(
        pos: Vec2.fromJson(j['base']['pos']),
        rotDeg: (j['base']['rotDeg'] as num).toDouble(),
        scale: Vec2.fromJson(j['base']['scale']),
      ),
      baseTrack: j['baseTrack'] != null ? _trackFromJson(j['baseTrack']) : null,
      visible: (j['visible'] ?? true) as bool,
      locked: (j['locked'] ?? false) as bool,
      pivot: j['pivot'] != null ? Vec2.fromJson(j['pivot']) : const Vec2(0, 0),
      parentId: j['parentId'],
      ikPoles: poles,
      lineWidthScale: (j['lineWidthScale'] as num?)?.toDouble() ?? 1.0,
      boneTracks: (j['boneTracks'] as Map<String, dynamic>).map((k, v) => MapEntry(k, _trackFromJson(v))),
      attachmentTracks: at,
      anchorTracks: ((j['anchorTracks'] as Map<String,dynamic>?) ?? const {}).map(
        (k,v) => MapEntry(k, (v as List).map((e)=> KeyF<Vec2>(e['t'] as int, Vec2.fromJson(e['v']))).toList())
      ),
    );
  }

  // ------------ raster layer ------------
  Future<Model> createRasterLayer({required int width, required int height}) async {
    final id = _uuid.v4();
    final imgPath = path.join(imagesDir.path, '$id.png');

    final recorder = ui.PictureRecorder();
    ui.Canvas(recorder); // no drawing; create empty picture
    // Transparent background by default (no fill)
    final pic = recorder.endRecording();
    final img = await pic.toImage(width, height);
    final bytes = await img.toByteData(format: ui.ImageByteFormat.png);
    if (bytes == null) {
      throw Exception('Failed to encode empty raster image');
    }
    await File(imgPath).writeAsBytes(bytes.buffer.asUint8List());
    await _ensureImageDecoded(imgPath);

    final m = Model(
      id: id,
      name: 'Raster $width x $height',
      bones: const [Bone(id: 'root', parentId: null, pivot: Vec2(0, 0), bind: Transform2D())],
      attachments: [Attachment(id: 'layer', boneId: 'root', type: PrimType.image, a: const Vec2(0, 0), b: Vec2(width.toDouble(), height.toDouble()), imagePath: imgPath)],
    );
    await saveUserModel(m);
    return m;
  }

  Map<String, dynamic> _trackToJson(TrackTransform t) => {
        'pos': t.pos.map((e) => {'t': e.t, 'v': e.v.toJson(), 'e': e.easing?.type}).toList(),
        'rot': t.rotDeg.map((e) => {'t': e.t, 'v': e.v, 'e': e.easing?.type}).toList(),
        'scale': t.scale.map((e) => {'t': e.t, 'v': e.v.toJson(), 'e': e.easing?.type}).toList(),
      };

  TrackTransform _trackFromJson(Map<String, dynamic> j) => TrackTransform(
        pos: (j['pos'] as List).map((e) => KeyF<Vec2>(e['t'], Vec2.fromJson(e['v']), easing: e['e'] != null ? Easing(e['e']) : null)).toList(),
        rotDeg: (j['rot'] as List).map((e) => KeyF<double>(e['t'], (e['v'] as num).toDouble(), easing: e['e'] != null ? Easing(e['e']) : null)).toList(),
        scale: (j['scale'] as List).map((e) => KeyF<Vec2>(e['t'], Vec2.fromJson(e['v']), easing: e['e'] != null ? Easing(e['e']) : null)).toList(),
      );

  // ------------ image helpers ------------
  Future<void> _ensureImageDecoded(String absPath) async {
    if (images.containsKey(absPath)) return;
    try {
      final f = File(absPath);
      if (!await f.exists()) return;
      final bytes = await f.readAsBytes();
      final c = Completer<ui.Image>();
      ui.decodeImageFromList(Uint8List.fromList(bytes), (img) => c.complete(img));
      final img = await c.future;
      images[absPath] = img;
    } catch (_) {}
  }

  Future<String> importImageToLibrary(String srcPath) async {
    final ext = path.extension(srcPath);
    final id = _uuid.v4();
    final dst = path.join(imagesDir.path, '$id$ext');
    await File(srcPath).copy(dst);
    await _ensureImageDecoded(dst);
    return dst;
  }

  Future<Model> createImageModel(String srcPath) async {
    final stored = await importImageToLibrary(srcPath);
    final img = images[stored];
    final w = (img?.width ?? 256).toDouble();
    final h = (img?.height ?? 256).toDouble();
    final m = Model(
      id: _uuid.v4(),
      name: path.basename(srcPath),
      bones: const [Bone(id: 'root', parentId: null, pivot: Vec2(0, 0), bind: Transform2D())],
      attachments: [Attachment(id: 'img', boneId: 'root', type: PrimType.image, a: const Vec2(0, 0), b: Vec2(w, h), imagePath: stored)],
    );
    await saveUserModel(m);
    return m;
  }

  Future<Model> createSpriteModel(List<String> paths) async {
    if (paths.isEmpty) throw Exception('이미지가 없습니다');
    final stored = <String>[];
    for (final pth in paths) {
      stored.add(await importImageToLibrary(pth));
    }
    final img = images[stored.first];
    final w = (img?.width ?? 128).toDouble();
    final h = (img?.height ?? 128).toDouble();
    final m = Model(
      id: _uuid.v4(),
      name: 'Sprite ${path.basename(paths.first)}(${paths.length})',
      bones: const [Bone(id: 'root', parentId: null, pivot: Vec2(0, 0), bind: Transform2D())],
      attachments: [Attachment(id: 'sprite', boneId: 'root', type: PrimType.image, a: const Vec2(0, 0), b: Vec2(w, h), imagePath: stored.first, spriteFrames: stored)],
    );
    await saveUserModel(m);
    return m;
  }

  // ------------ projects ------------
  Future<Project> createProject(String name) async {
    final pjt = Project(id: _uuid.v4(), name: name, sequences: [], lastOpened: DateTime.now().millisecondsSinceEpoch, favorite: false);
    projects.add(pjt);
    await _saveProjects();
    return pjt;
  }

  Future<Sequence> createSequence(Project p, String name) async {
    return createSequenceWithSetting(p, name, const SequenceSetting());
  }

  Future<Sequence> createSequenceWithSetting(Project p, String name, SequenceSetting setting) async {
    final s = Sequence(id: _uuid.v4(), name: name, setting: setting, onion: const OnionSkinSetting(), instances: [], audio: const []);
    final idx = projects.indexWhere((x) => x.id == p.id);
    projects[idx] = Project(id: p.id, name: p.name, sequences: [...p.sequences, s]);
    await _saveProjects();
    return s;
  }

  Future<void> renameSequence(Project p, Sequence s, String newName) async {
    final pi = projects.indexWhere((x) => x.id == p.id);
    if (pi < 0) return;
    final newSeqs = p.sequences.map((e) => e.id == s.id ? e.copyWith(name: newName) : e).toList();
    projects[pi] = Project(id: p.id, name: p.name, sequences: newSeqs, lastOpened: p.lastOpened, favorite: p.favorite);
    await _saveProjects();
  }

  Future<void> deleteSequence(Project p, Sequence s) async {
    final pi = projects.indexWhere((x) => x.id == p.id);
    if (pi < 0) return;
    final newSeqs = List<Sequence>.from(p.sequences)..removeWhere((e) => e.id == s.id);
    projects[pi] = Project(id: p.id, name: p.name, sequences: newSeqs, lastOpened: p.lastOpened, favorite: p.favorite);
    await _saveProjects();
  }

  Future<Sequence> duplicateSequence(Project p, Sequence s, {String? name}) async {
    final pi = projects.indexWhere((x) => x.id == p.id);
    if (pi < 0) return s;
    final dup = Sequence(
      id: _uuid.v4(),
      name: name ?? 'Copy of ${s.name}',
      setting: s.setting,
      onion: s.onion,
      instances: List<Instance>.from(s.instances),
      audio: List<AudioTrack>.from(s.audio),
    );
    final newSeqs = <Sequence>[];
    for (final e in p.sequences) {
      newSeqs.add(e);
      if (e.id == s.id) newSeqs.add(dup);
    }
    projects[pi] = Project(id: p.id, name: p.name, sequences: newSeqs, lastOpened: p.lastOpened, favorite: p.favorite);
    await _saveProjects();
    return dup;
  }

  Future<void> upsertProject(Project p) async {
    final idx = projects.indexWhere((x) => x.id == p.id);
    if (idx >= 0) projects[idx] = p;
    await _saveProjects();
  }

  Future<void> renameProject(Project p, String newName) async {
    final idx = projects.indexWhere((x) => x.id == p.id);
    if (idx < 0) return;
    projects[idx] = Project(id: p.id, name: newName, sequences: p.sequences, lastOpened: p.lastOpened, favorite: p.favorite);
    await _saveProjects();
  }

  Future<void> deleteProject(Project p) async {
    projects.removeWhere((x) => x.id == p.id);
    await _saveProjects();
    try {
      final dir = Directory(path.join(autosaveDir.path, p.id));
      if (dir.existsSync()) dir.deleteSync(recursive: true);
    } catch (_) {}
  }

  Future<void> markProjectOpened(Project p) async {
    final idx = projects.indexWhere((x) => x.id == p.id);
    if (idx < 0) return;
    final now = DateTime.now().millisecondsSinceEpoch;
    projects[idx] = Project(id: p.id, name: p.name, sequences: p.sequences, lastOpened: now, favorite: p.favorite);
    await _saveProjects();
  }

  Future<void> setProjectFavorite(Project p, bool fav) async {
    final idx = projects.indexWhere((x) => x.id == p.id);
    if (idx < 0) return;
    projects[idx] = Project(id: p.id, name: p.name, sequences: p.sequences, lastOpened: p.lastOpened, favorite: fav);
    await _saveProjects();
  }

  // ------------ .sma bundle ------------
  Future<File> exportBundle(Project proj) async {
    final tmp = await getTemporaryDirectory();
    final outFile = File(path.join(tmp.path, 'StickMotion_${proj.name}_${DateTime.now().millisecondsSinceEpoch}.sma'));
    final arch = Archive();

    final usedModelIds = <String>{};
    for (final sequence in proj.sequences) {
      for (final instance in sequence.instances) {
        usedModelIds.add(instance.modelId);
      }
    }

    for (final mid in usedModelIds) {
      if (mid == 'stickman') continue;
      final m = models[mid];
      if (m != null) {
        final j = m.toJson();
        final imagesToAdd = <String, String>{};
        int idx = 0;
        for (final a in (j['attachments'] as List)) {
          if (a['type'] == 'image') {
            if (a['imagePath'] != null) {
              final abs = a['imagePath'] as String;
              final rel = 'images/${mid}_$idx${path.extension(abs)}';
              a['imagePath'] = rel;
              imagesToAdd[abs] = rel;
              idx += 1;
            }
            if (a['spriteFrames'] != null) {
              final frames = (a['spriteFrames'] as List).map((e) => e.toString()).toList();
              final newFrames = <String>[];
              for (int fi = 0; fi < frames.length; fi++) {
                final abs = frames[fi];
                final rel = 'images/${mid}_spr_$fi${path.extension(abs)}';
                imagesToAdd[abs] = rel;
                newFrames.add(rel);
              }
              a['spriteFrames'] = newFrames;
