  void _finalizeLassoSelection() {
    _lassoSelection = <String>{};
    if (_lassoPoints.length < 3) return;
    final path = _lassoPoints.map((p) => (p - widget.viewportOffset) / widget.viewportScale).toList();
    final inst = widget.sequence.instances.firstWhere((x)=> x.id==widget.selectedInstanceId, orElse: ()=> const Instance(id:'', name:'', modelId:'', base: Transform2D()));
    final model = widget.models[inst.modelId]; if (inst.id.isEmpty || model==null) return;
    final bones = {for (final b in model.bones) b.id: b};
    final pose = _poseOf(inst, widget.t, interpolate: widget.sequence.setting.interpolate);
    final cache = <String, vm.Matrix4>{};
    final instWorld = _instanceWorld(widget.sequence.instances, inst, widget.t, widget.sequence.setting.interpolate);
    Offset sum = Offset.zero; int cnt = 0;
    for (final b in model.bones) {
      final m = instWorld * SkeletonUtil.worldOf(b, pose, bones, cache);
      final wp = _tx(m, Offset(b.pivot.x, b.pivot.y));
      if (_pointInPolygon(wp, path)) {
        _lassoSelection.add(b.id);
        sum += wp; cnt++;
      }
    }
    _lassoCenterWorld = cnt>0 ? sum/ cnt.toDouble() : null;
    setState(() {});
  }

  bool _pointInPolygon(Offset p, List<Offset> poly) {
    bool inside = false;
    for (int i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      final xi = poly[i].dx, yi = poly[i].dy;
      final xj = poly[j].dx, yj = poly[j].dy;
      final cond = ((yi > p.dy) != (yj > p.dy)) && (p.dx < (xj - xi) * (p.dy - yi) / ((yj - yi).abs() < 1e-6 ? 1e-6 : (yj - yi)) + xi);
      if (cond) inside = !inside;
    }
    return inside;
  }

  void _applyLassoTranslate(Instance inst, Model model, Offset deltaWorld) {
    if (_lassoSelection.isEmpty) return;
    if (widget.stickMode) return; // Stick Fighter 모드: 본 이동 금지
    final frame = widget.t.round();
    final newTracks = Map<String, TrackTransform>.from(inst.boneTracks);
    void moveBone(String bid) {
      final tr = newTracks[bid] ?? const TrackTransform();
      final pos = List<KeyF<Vec2>>.from(tr.pos);
      final i = pos.indexWhere((k)=> k.t==frame);
      final cur = i>=0 ? pos[i].v : const Vec2(0,0);
      final next = Vec2(cur.x + deltaWorld.dx, cur.y + deltaWorld.dy);
      final kv = KeyF<Vec2>(frame, next);
      if (i>=0) pos[i]=kv; else if (widget.autoKey) pos.add(kv);
      newTracks[bid] = TrackTransform(pos: pos, rotDeg: tr.rotDeg, scale: tr.scale);
    }
    for (final bid in _lassoSelection) { moveBone(bid); }
    widget.onChange(inst.copyWith(boneTracks: newTracks));
  }

  void _applyLassoRotate(Instance inst, Model model, double deltaDeg) {
    if (_lassoSelection.isEmpty) return;
    final frame = widget.t.round();
    final newTracks = Map<String, TrackTransform>.from(inst.boneTracks);
    void rotBone(String bid) {
      final tr = newTracks[bid] ?? const TrackTransform();
      final rot = List<KeyF<double>>.from(tr.rotDeg);
      // sample current rotation at frame (step)
      double cur = 0.0;
      if (tr.rotDeg.isNotEmpty) {
        cur = sampleScalarD(tr.rotDeg, frame.toDouble());
      }
      final next = cur + deltaDeg;
      final i = rot.indexWhere((k)=> k.t==frame);
      final kv = KeyF<double>(frame, next);
      if (i>=0) rot[i]=kv; else if (widget.autoKey) rot.add(kv);
      newTracks[bid] = TrackTransform(pos: tr.pos, rotDeg: rot, scale: tr.scale);
    }
    for (final bid in _lassoSelection) { rotBone(bid); }
    widget.onChange(inst.copyWith(boneTracks: newTracks));
  }

  void _applyLassoScale(Instance inst, Model model, double factor) {
    if (_lassoSelection.isEmpty || _lassoCenterWorld == null) return;
    if (widget.stickMode) return; // Stick Fighter 모드: 본 스케일 금지
    final frame = widget.t.round();
    final newTracks = Map<String, TrackTransform>.from(inst.boneTracks);

    final bonesById = {for (final b in widget.models[inst.modelId]!.bones) b.id: b};
    final pose = _poseOf(inst, widget.t, interpolate: widget.sequence.setting.interpolate);
    final cache = <String, vm.Matrix4>{};
    final instWorld = _instanceWorld(widget.sequence.instances, inst, widget.t, widget.sequence.setting.interpolate);

    void scaleBone(String bid) {
      final b = bonesById[bid]; if (b == null) return;
      // Current world pivot
      final bw = instWorld * SkeletonUtil.worldOf(b, pose, bonesById, cache);
      final curW = _tx(bw, Offset(b.pivot.x, b.pivot.y));
      // Target world pivot scaled about center
      final v = curW - _lassoCenterWorld!;
      final tgtW = _lassoCenterWorld! + Offset(v.dx * factor, v.dy * factor);
      final deltaW = tgtW - curW;
      if (deltaW.distance < 1e-6) return;
      // Parent world matrix
      vm.Matrix4 parentW;
      if (b.parentId != null) {
        final pb = bonesById[b.parentId]!;
        parentW = instWorld * SkeletonUtil.worldOf(pb, pose, bonesById, cache);
      } else {
        parentW = instWorld;
      }
      final invParent = vm.Matrix4.inverted(parentW);
      final dv = invParent.transform3(vm.Vector3(deltaW.dx, deltaW.dy, 0));

      final tr = newTracks[bid] ?? const TrackTransform();
      final pos = List<KeyF<Vec2>>.from(tr.pos);
      final i = pos.indexWhere((k)=> k.t==frame);
      final cur = i>=0 ? pos[i].v : const Vec2(0,0);
      final next = Vec2(cur.x + dv.x, cur.y + dv.y);
      final kv = KeyF<Vec2>(frame, next);
      if (i>=0) pos[i]=kv; else if (widget.autoKey) pos.add(kv);
      newTracks[bid] = TrackTransform(pos: pos, rotDeg: tr.rotDeg, scale: tr.scale);
    }
    for (final bid in _lassoSelection) { scaleBone(bid); }
    widget.onChange(inst.copyWith(boneTracks: newTracks));
  }

