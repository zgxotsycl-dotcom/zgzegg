      if (_lassoMove) {
        final world = (e.position - widget.viewportOffset) / widget.viewportScale;
        final delta = world - _lassoMoveStartWorld;
        _applyLassoTranslate(inst, model, delta);
        _lassoMoveStartWorld = world;
        return;
      }
      if (_lassoDrawing) {
        _lassoPoints.add(e.position);
        setState(() {});
        return;
      }
    }
    if (_dragBase) {
      _dragPointerCurrent = e.position;
      final worldDelta = (e.position - _dragPointerStart) / widget.viewportScale;
      final invParent = vm.Matrix4.inverted(_parentWorldAtStart!);
      final v = invParent.transform3(vm.Vector3(worldDelta.dx, worldDelta.dy, 0));
      final localDelta = Vec2(v.x, v.y);
      final start = _baseStartPos ?? const Vec2(0,0);
      final newPos = Vec2(start.x + localDelta.x, start.y + localDelta.y);

      // Upsert baseTrack pos key at current frame
      final frame = widget.t.round();
      final bt = inst.baseTrack ?? const TrackTransform();
      final posKeys = List<KeyF<Vec2>>.from(bt.pos);
      final i = posKeys.indexWhere((k) => k.t == frame);
      final kv = KeyF<Vec2>(frame, newPos);
      if (i >= 0) {
        posKeys[i] = kv;
      } else {
        posKeys.add(kv);
      }
      final updated = inst.copyWith(baseTrack: TrackTransform(pos: posKeys, rotDeg: bt.rotDeg, scale: bt.scale));
      widget.onChange(updated);
      return;
    }

    // IK end-effector drag
    if (_dragIkBoneId != null) {
      if (widget.stickMode) return; // Stick Fighter 모드: IK 비활성화
      final world = (e.position - widget.viewportOffset) / widget.viewportScale;
      final updated = _applyTwoBoneIk(inst, model, _dragIkBoneId!, world);
      if (updated != null) widget.onChange(updated);
      return;
    }

    // Base rotate drag
    if (_dragBaseRotate) {
      _dragPointerCurrent = e.position;
      final instW = _instanceWorld(widget.sequence.instances, inst, widget.t, widget.sequence.setting.interpolate);
      final pivotWorld = _tx(instW, Offset(inst.pivot.x, inst.pivot.y));
      final world = (e.position - widget.viewportOffset) / widget.viewportScale;
      final v = world - pivotWorld;
      if (v.distance < 1e-6) return;
      final ang = math.atan2(v.dy, v.dx);
      final parentW = _parentWorldAtStart ?? vm.Matrix4.identity();
      final parentY = _angleOfYAxis(parentW);
      double localDeg = _radToDeg(ang - parentY);
      if (widget.angleSnap) {
