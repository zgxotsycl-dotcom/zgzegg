        canvas.drawRect(rect, stroke);
      }
    }

    // Draw end-effector handle for two-bone chain
    if (tool == 'ik' && selectedBoneId != null) {
      final sel = selectedBoneId!;
      final chain = _findTwoBoneChainLocal(model!, sel);
      if (chain != null) {
        final lower = chain.item2;
        final lw = instWorld * SkeletonUtil.worldOf(lower, pose, bones, cache);
        // Prefer child's pivot as tip if exists
        final child = model!.bones.firstWhere(
          (x) => x.parentId == lower.id,
          orElse: () => const Bone(id: '', parentId: null, pivot: Vec2(0,0), bind: Transform2D()),
        );
        Offset tip;
        if (child.id.isNotEmpty) {
          final cw = instWorld * SkeletonUtil.worldOf(child, pose, bones, cache);
          tip = _w2s(_tx(cw, Offset(child.pivot.x, child.pivot.y)));
        } else {
          tip = _w2s(_tx(lw, Offset(0, _boneLengthLocal(model!, lower.id))));
        }
        const double jointRadius = 10.0;
        final fill = Paint()..color = const ui.Color(0xFFFDD835); // amber
        final stroke = Paint()
          ..style = PaintingStyle.stroke
          ..strokeWidth = 2
          ..color = const ui.Color(0xFF5D4037);
        canvas.drawCircle(tip, jointRadius, fill);
        canvas.drawCircle(tip, jointRadius, stroke);
      }
    }

    // Lasso overlay (points and selection highlight)
    if (tool == 'lasso') {
      if (lassoPoints != null && lassoPoints!.length > 1) {
        final path = Path()..moveTo(lassoPoints!.first.dx, lassoPoints!.first.dy);
        for (final p in lassoPoints!.skip(1)) { path.lineTo(p.dx, p.dy); }
        final pen = Paint()
          ..style = PaintingStyle.stroke
          ..strokeWidth = 2
          ..color = const ui.Color(0xFF42A5F5);
        canvas.drawPath(path, pen);
      }
      if (lassoSelection != null && lassoSelection!.isNotEmpty) {
        final selPaint = Paint()..color = const ui.Color(0xFF42A5F5).withOpacity(0.9);
        for (final b in m.bones) {
          if (!lassoSelection!.contains(b.id)) continue;
          final w = instWorld * SkeletonUtil.worldOf(b, pose, bones, cache);
          final p0w = _tx(w, Offset(b.pivot.x, b.pivot.y));
          final p0 = _w2s(p0w);
          canvas.drawCircle(p0, 5, selPaint);
        }
        if (lassoCenterWorld != null) {
          final c = _w2s(lassoCenterWorld!);
          // Draw rotate handle (top)
          final rot = c + const Offset(0, -40);
          final sc = c + const Offset(40, 0);
          final hp = Paint()..color = const ui.Color(0xFF42A5F5);
          final hs = Paint()
            ..style = PaintingStyle.stroke
            ..strokeWidth = 2
            ..color = const ui.Color(0xFF1565C0);
          canvas.drawCircle(rot, 8, hp); canvas.drawCircle(rot, 8, hs);
          canvas.drawCircle(sc, 8, hp); canvas.drawCircle(sc, 8, hs);
          // Center mark
          canvas.drawCircle(c, 3, hp);
        }
      }
    }
  }

  @override
  bool shouldRepaint(covariant _GizmoPainter old) {
    return old.inst != inst ||
        old.model != model ||
        old.t != t ||
        old.tool != tool ||
        old.boneMode != boneMode ||
        old.selectedBoneId != selectedBoneId ||
        old.activePoleBoneId != activePoleBoneId ||
        old.viewportScale != viewportScale ||
        old.viewportOffset != viewportOffset;
  }

  static vm.Matrix4 _instanceWorld(List<Instance> instances, Instance inst, double t, bool interpolate) {
    vm.Matrix4 acc = vm.Matrix4.identity();
    final byId = {for (final x in instances) x.id: x};
    // Build chain from root to this
    final chain = <Instance>[];
    Instance? cur = inst;
    final visited = <String>{};
    while (cur != null) {
      if (visited.contains(cur.id)) break;
      visited.add(cur.id);
      chain.add(cur);
      if (cur.parentId == null) break;
      cur = byId[cur.parentId!];
    }
    for (final it in chain.reversed) {
      final bt = it.baseTrack;
      final tr = bt == null ? it.base : sampleTransform(bt, t, interpolate: interpolate);
      acc = acc * composeMatrix(tr, it.pivot);
    }
    return acc;
  }

  static Offset _tx(vm.Matrix4 m, Offset o) {
    final v = m.transform3(vm.Vector3(o.dx, o.dy, 0));
    return Offset(v.x, v.y);
  }

  // Helpers replicated for painter scope
  _Pair? _findTwoBoneChainLocal(Model model, String chosenId) {
    final byId = {for (final b in model.bones) b.id: b};
    final initialLower = byId[chosenId];
    if (initialLower == null) return null;

    Bone upper;
    Bone lower;

    if (initialLower.parentId != null) {
      final parent = byId[initialLower.parentId!];
      if (parent == null) {
        return null;
      }
      upper = parent;
      lower = initialLower;
    } else {
      final children = model.bones.where((x) => x.parentId == chosenId).toList();
      if (children.isEmpty) return null;
      children.sort((a, b) => _boneLengthLocal(model, b.id).compareTo(_boneLengthLocal(model, a.id)));
      upper = initialLower;
      final child = byId[children.first.id];
      if (child == null) return null;
      lower = child;
    }
    return _Pair(upper, lower);
  }

  double _boneLengthLocal(Model model, String boneId) {
    final child = model.bones.firstWhere(
      (x) => x.parentId == boneId,
      orElse: () => const Bone(id: '', parentId: null, pivot: Vec2(0,0), bind: Transform2D()),
    );
    if (child.id.isNotEmpty) {
      final v = child.bind.pos;
      final l = math.sqrt(v.x * v.x + v.y * v.y);
      if (l > 1e-3) return l;
    }
    final att = model.attachments.firstWhere(
      (a) => a.boneId == boneId && a.type == PrimType.line,
      orElse: () => const Attachment(id: '', boneId: '', type: PrimType.line),
    );
    if (att.id.isNotEmpty) {
      final b = att.b;
      final l = math.sqrt(b.x * b.x + b.y * b.y);
      if (l > 1e-3) return l;
    }
    return 60.0;
  }
}

class _Pair {
  final Bone item1;
  final Bone item2;
  const _Pair(this.item1, this.item2);
}

